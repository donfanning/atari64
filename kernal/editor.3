
KEYCOD	;KEYBOARD MODE 'DISPATCH'
	.WORD MODE1
	.WORD MODE2
	.WORD MODE3
	.WORD CONTRL    ;CONTROL KEYS

; TODO: assign to PETSCII F1-F7 or F1-F4
F1KEY = $FF
F2KEY = $FF
F3KEY = $FF
F4KEY = $FF
; TODO: find out what to do to logo key
HELPKEY = $FF
LOGOKEY = $FF
TABKEY = $5F ; left arrow
CAPSKEY = $FF
DELKEY = $14

MODE1
	.BYTE "LJ;",F1KEY,F3KEY,"K+*"
	.BYTE "O",$FF,"PU",$0D,"I-="
	.BYTE "V",HELPKEY,"C",F3KEY,F4KEY,"BXZ"
	.BYTE "4",$FF,"36",$03,"521"
	.BYTE ", .N",$FF,"M/",LOGOKEY
	.BYTE "R",$FF,"EY",TABKEY,"TWQ"
	.BYTE "9",$FF,"07",DELKEY,"8<>"
	.BYTE "FHD",$FF,CAPSKEY,"GSA"
	.BYTE $FF        ;END OF TABLE NULL

MODE2	;SHIFT
	.BYTE $CC,$CA,":",F1KEY,F3KEY,$CB,"\^"
	.BYTE $CF,$FF,$D0,$D5,$8D,$C9,"_|"
	.BYTE $D6,HELPKEY,$C3,F3KEY,F4KEY,$C2,$D8,$DA
	.BYTE $24,$FF,$23,$26,$03,$25,$22,$21
	.BYTE "[",$A0,"]",$CE,$FF,$CD,"?",LOGOKEY
	.BYTE $D2,0,$C5,$D9,TABKEY,$D4,$D7,$D1
	.BYTE "(",0,")'",DELKEY,"@",$93,$94
	.BYTE $C6,$C8,$C4,$FF,CAPSKEY,$C7,$D3,$C1
	.BYTE $FF        ;END OF TABLE NULL
;
MODE3	;LEFT WINDOW GRAHPICS
	.BYTE "LJ;",F1KEY,F3KEY,"K+*"
	.BYTE "O",0,"PU",$0D,"I-="
	.BYTE "V",HELPKEY,"C",F3KEY,F4KEY,"BXZ"
	.BYTE "4",0,"36",$03,"521"
	.BYTE ", .N",0,"M/",LOGOKEY
	.BYTE "R",0,"EY",TABKEY,"TWQ"
	.BYTE "9",0,"07",DELKEY,"8<>"
	.BYTE "FHD",0,CAPSKEY,"GSA"
	.BYTE $FF        ;END OF TABLE NULL

LOWER
	CMP #$0E        ;DOES HE WANT LOWER CASE?
	BNE UPPER       ;BRANCH IF NOT
	;LDA VICREG+24   ;ELSE SET VIC TO POINT TO LOWER CASE
	;ORA #$02
	LDA #$DC     ; #>CHARGEN+4
	BNE ULSET       ;JMP

UPPER
	CMP #$8E        ;DOES HE WANT UPPER CASE
	BNE LOCK        ;BRANCH IF NOT
	;LDA VICREG+24   ;MAKE SURE VIC POINT TO UPPER/PET SET
	;AND #$FF-$02
	LDA #$D8     ; #>CHARGEN
ULSET	STA CHBASE
	; TODO: create shadow register somewhere
	; so that SHIFT-C= type toggle can work
OUTHRE	JMP LOOP2

LOCK
	CMP #8          ;DOES HE WANT TO LOCK IN THIS MODE?
	BNE UNLOCK      ;BRANCH IF NOT
	LDA #$80        ;ELSE SET LOCK SWITCH ON
	ORA MODE        ;DON'T HURT ANYTHING - JUST IN CASE
	BMI LEXIT

UNLOCK
	CMP #9          ;DOES HE WANT TO UNLOCK THE KEYBOARD?
	BNE OUTHRE      ;BRANCH IF NOT
	LDA #$7F        ;CLEAR THE LOCK SWITCH
	AND MODE        ;DONT HURT ANYTHING
LEXIT	STA MODE
	JMP LOOP2       ;GET OUT

; 142=up = 128+14
; 143=down  +15
; 134=left  +6
; 135=right +7
CONTRL
	.BYTE $0C,$0A,$FF,$FF,$FF,$0B,$9D,$1D
	.BYTE $0F,$FF,$10,$15,$8D,$09,$91,$11
	.BYTE $16,HELPKEY,$03,F3KEY,F4KEY,$02,$18,$1A
	.BYTE $34,$FF,$33,$36,$03,$35,$05,$31
	.BYTE $1B,$A0,$1D,$0E,$FF,$0D,$1F,LOGOKEY
	.BYTE $12,$FF,$05,$19,TABKEY,$14,$17,$11
	.BYTE $12,$FF,$92,"'",DELKEY,"@",$93,$94
	.BYTE $06,$08,$04,$FF,CAPSKEY,$07,$13,$01
	.BYTE $FF        ;END OF TABLE NULL
TVIC ;deprecated
TGTIA
	.BYTE 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;SPRITES (0-16)
        .BYTE 0        
        ; Default P/M Colors
        .BYTE $00, $00, $00, $00 
        ; Default Playfield Colors
        .BYTE $28, $CA, $94, $46, $9A
        ; no goofy GTIA mode
        .BYTE $00
	;.BYTE $9B,55,0,0,0,$08,0,$14,$0F,0,0,0,0,0,0 ;DATA (17-31) RC= 311
	;.BYTE 14,6,1,2,3,4,0,1,2,3,4,5,6,7 ;32-46
TANTIC
        .BYTE $22  ; DMACTL -- to be checked
        .BYTE $02  ; CHACTL ... 755?
        .WORD ROMDLIST ; DLISTL/DLISTH
	.BYTE $0, $0   ; HSCROL, VSCROL
        .BYTE $0, $0   ; unknown
	.BYTE $0       ; PMBASE
	.BYTE $D8      ; CHBASE at $D409 (todo: label)
        .BYTE $0       ; VCOUNT
	.BYTE $40      ; NMIEN
        .BYTE $C0      ; NMIRES
TANTICEND

ROMDLIST
	.BYTE $70,$70 ; 16 blank scanlines
	.BYTE $42  ; first line, set address
	.WORD $0400  ; hard-code screen location
	.BYTE $02,$02,$02,$02,$02,$02,$02,$02
	.BYTE $02,$02,$02,$02,$02,$02,$02,$02
	.BYTE $02,$02,$02,$02,$02,$02,$02,$02
	.BYTE $41 ; GOTO after vblank
	.WORD ROMDLIST
;
RUNTB	.BYTE "LOAD",$D,"RUN",$D
;
LINZ0	=  VICSCN
LINZ1	=  LINZ0+LLEN
LINZ2	=  LINZ1+LLEN
LINZ3	=  LINZ2+LLEN
LINZ4	=  LINZ3+LLEN
LINZ5	=  LINZ4+LLEN
LINZ6	=  LINZ5+LLEN
LINZ7	=  LINZ6+LLEN
LINZ8	=  LINZ7+LLEN
LINZ9	=  LINZ8+LLEN
LINZ10	=  LINZ9+LLEN
LINZ11	=  LINZ10+LLEN
LINZ12	=  LINZ11+LLEN
LINZ13	=  LINZ12+LLEN
LINZ14	=  LINZ13+LLEN
LINZ15	=  LINZ14+LLEN
LINZ16	=  LINZ15+LLEN
LINZ17	=  LINZ16+LLEN
LINZ18	=  LINZ17+LLEN
LINZ19	=  LINZ18+LLEN
LINZ20	=  LINZ19+LLEN
LINZ21	=  LINZ20+LLEN
LINZ22	=  LINZ21+LLEN
LINZ23	=  LINZ22+LLEN
LINZ24	=  LINZ23+LLEN

;****** SCREEN LINES LO BYTE TABLE ******
;
LDTB2
	.BYTE <LINZ0
	.BYTE <LINZ1
	.BYTE <LINZ2
	.BYTE <LINZ3
	.BYTE <LINZ4
	.BYTE <LINZ5
	.BYTE <LINZ6
	.BYTE <LINZ7
	.BYTE <LINZ8
	.BYTE <LINZ9
	.BYTE <LINZ10
	.BYTE <LINZ11
	.BYTE <LINZ12
	.BYTE <LINZ13
	.BYTE <LINZ14
	.BYTE <LINZ15
	.BYTE <LINZ16
	.BYTE <LINZ17
	.BYTE <LINZ18
	.BYTE <LINZ19
	.BYTE <LINZ20
	.BYTE <LINZ21
	.BYTE <LINZ22
	.BYTE <LINZ23
	.BYTE <LINZ24

; RSR 12/08/81 MODIFY FOR VIC-40 KEYSCAN <= = HI BOB!
; RSR  2/17/81 MODIFY FOR THE STINKING 6526R2 CHIP
; RSR  3/11/82 MODIFY FOR COMMODORE 64
; RSR  3/28/82 MODIFY FOR NEW PLA
; RSR  6/22/82 ADD 311 PLA RASTER COMPARE
