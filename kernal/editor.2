
;SCREEN SCROLL ROUTINE
;
SCROL	LDA SAL
	PHA
	LDA SAH
	PHA
;
;   S C R O L L   U P
;
SCRO0	LDX #$FF
	DEC TBLX
	DEC LSXP
	DEC LINTMP
SCR10	INX             ;GOTO NEXT LINE
	JSR SETPNT      ;POINT TO 'TO' LINE
	CPX #NLINES-1   ;DONE?
	BCS SCR41       ;BRANCH IF SO
;
	LDA LDTB2+1,X   ;SETUP FROM PNTR
	STA SAL
	LDA LDTB1+1,X
	JSR SCRLIN      ;SCROLL THIS LINE UP1
	BMI SCR10
;
SCR41
	JSR CLRLN
;
	LDX #0          ;SCROLL HI BYTE POINTERS
SCRL5	LDA LDTB1,X
	AND #$7F
	LDY LDTB1+1,X
	BPL SCRL3
	ORA #$80
SCRL3	STA LDTB1,X
	INX
	CPX #NLINES-1
	BNE SCRL5
;
	LDA LDTB1+NLINES-1
	ORA #$80
	STA LDTB1+NLINES-1
	LDA LDTB1       ;DOUBLE LINE?
	BPL SCRO0       ;YES...SCROLL AGAIN
;
	INC TBLX
	INC LINTMP
	; check for slow scroll
	; can't decide which start/select/option
        ; so i'll just check all of them
	LDA 53279
	AND #7
	CMP #7
	BEQ MLP42 ; branch if no buttons pressed
;
	LDY #0
MLP4	NOP             ;DELAY
	DEX
	BNE MLP4
	DEY
	BNE MLP4
	STY NDX         ;CLEAR KEY QUEUE BUFFER
;
MLP42	LDX TBLX
;
PULIND	PLA             ;RESTORE OLD INDIRECTS
	STA SAH
	PLA
	STA SAL
	RTS

NEWLIN
	LDX TBLX
BMT1	INX
; CPX #NLINES ;EXCEDED THE NUMBER OF LINES ???
; BEQ BMT2 ;VIC-40 CODE
	LDA LDTB1,X     ;FIND LAST DISPLAY LINE OF THIS LINE
	BPL BMT1        ;TABLE END MARK= >$FF WILL ABORT...ALSO
BMT2	STX LINTMP      ;FOUND IT
;GENERATE A NEW LINE
	CPX #NLINES-1   ;IS ONE LINE FROM BOTTOM?
	BEQ NEWLX       ;YES...JUST CLEAR LAST
	BCC NEWLX       ;<NLINES...INSERT LINE
	JSR SCROL       ;SCROLL EVERYTHING
	LDX LINTMP
	DEX
	DEC TBLX
	JMP WLOG30
NEWLX	LDA SAL
	PHA
	LDA SAH
	PHA
	LDX #NLINES
SCD10	DEX
	JSR SETPNT      ;SET UP TO ADDR
	CPX LINTMP
	BCC SCR40
	BEQ SCR40       ;BRANCH IF FINISHED
	LDA LDTB2-1,X   ;SET FROM ADDR
	STA SAL
	LDA LDTB1-1,X
	JSR SCRLIN      ;SCROLL THIS LINE DOWN
	BMI SCD10
SCR40
	JSR CLRLN
	LDX #NLINES-2
SCRD21
	CPX LINTMP      ;DONE?
	BCC SCRD22      ;BRANCH IF SO
	LDA LDTB1+1,X
	AND #$7F
	LDY LDTB1,X     ;WAS IT CONTINUED
	BPL SCRD19      ;BRANCH IF SO
	ORA #$80
SCRD19	STA LDTB1+1,X
	DEX
	BNE SCRD21
SCRD22
	LDX LINTMP
	JSR WLOG30
;
	JMP PULIND      ;GO PUL OLD INDIRECTS AND RETURN
;
; SCROLL LINE FROM SAL TO PNT
;
SCRLIN
	AND #$03        ;CLEAR ANY GARBAGE STUFF
	ORA HIBASE      ;PUT IN HIORDER BITS
	STA SAL+1
	LDY #LLEN-1
SCD20
	LDA (SAL),Y
	STA (PNT),Y
	DEY
	BPL SCD20
	RTS
;
; SET UP PNT AND Y
; FROM .X
;
SETPNT	LDA LDTB2,X
	STA PNT
	LDA LDTB1,X
	AND #$03
	ORA HIBASE
	STA PNT+1
	RTS
;
; CLEAR THE LINE POINTED TO BY .X
;
CLRLN	LDY #LLEN-1
	JSR SETPNT
CLR10	LDA #$20        ;STORE A SPACE
	STA (PNT),Y     ;TO DISPLAY
	DEY
	BPL CLR10
	RTS
	NOP

;
;PUT A CHAR ON THE SCREEN
;
DSPP	TAY             ;SAVE CHAR
	LDA #2
	STA BLNCT       ;BLINK CURSOR
	;JSR SCOLOR      ;SET COLOR PTR
	TYA             ;RESTORE COLOR
DSPP2	LDY PNTR        ;GET COLUMN
	STA (PNT),Y      ;CHAR TO SCREEN
	;TXA
	;STA (USER),Y     ;COLOR TO SCREEN
	RTS

SCOLOR	RTS

KEY	JSR $FFEA       ;UPDATE JIFFY CLOCK
	LDA BLNSW       ;BLINKING CRSR ?
	BNE KEY4        ;NO
	DEC BLNCT       ;TIME TO BLINK ?
	BNE KEY4        ;NO
	LDA #20         ;RESET BLINK COUNTER
REPDO	STA BLNCT
	LDY PNTR        ;CURSOR POSITION
	LSR BLNON       ;CARRY SET IF ORIGINAL CHAR
	LDX GDCOL       ;GET CHAR ORIGINAL COLOR
	LDA (PNT),Y      ;GET CHARACTER
	BCS KEY5        ;BRANCH IF NOT NEEDED
;
	INC BLNON       ;SET TO 1
	STA GDBLN       ;SAVE ORIGINAL CHAR
	JSR SCOLOR
	LDX COLOR       ;BLINK IN THIS COLOR
	LDA GDBLN       ;WITH ORIGINAL CHARACTER
;
KEY5	EOR #$80        ;BLINK IT
	JSR DSPP2       ;DISPLAY IT
;
KEY4	LDA R6510       ;GET CASSETTE SWITCHES
	AND #$10        ;IS SWITCH DOWN ?
	BEQ KEY3        ;BRANCH IF SO
;
	LDY #0
	STY CAS1        ;CASSETTE OFF SWITCH
;
	LDA R6510
	ORA #$20
	BNE KL24        ;BRANCH IF MOTOR IS OFF
;
KEY3	LDA CAS1
	BNE KL2
;
	LDA R6510
	AND #%011111    ;TURN MOTOR ON
;
KL24
	STA R6510
;
KL2	JSR SCNKEY      ;SCAN KEYBOARD
;
KPREND	LDA #0
        STA NMIRES      ;CLEAR INTERRUPT FLAGS
	PLA             ;RESTORE REGISTERS
	TAY
	PLA
	TAX
	PLA
	RTI             ;EXIT FROM IRQ ROUTINES

; ****** GENERAL KEYBOARD SCAN ******
;
; c64 sfdx uses 64 as null key?

SCNKEY	LDA #$00
	STA SHFLAG
	LDY #64         ;LAST KEY INDEX
	STY SFDX        ;NULL KEY FOUND
	LDA SKSTAT      ;CHECK FOR A KEY DOWN
	AND #$04        ;NO KEYS DOWN?
	LDX #$FF        ; reproduce previous logic that
	EOR #$04        ; follows BEQ chain to CKIT2
	BEQ SCNOUT      ;BRANCH IF NONE
	LDA #0
	STA STKEY	; clear stop key
	TAY  
	; there is a key.  do shift/ctrl keys
	BIT KBCODE
	BPL NOCTRL
	ORA #$04
NOCTRL	BVC NOSHIFT
	ORA #$01
NOSHIFT	TAY
	; any of the rightmost keys acts as C=
	LDA 53279 ; OPT/SELECT/SHIFT
	AND #$07
	CMP #$07
	BEQ NOCBMKEY
	INY
	INY
NOCBMKEY	TYA
	STA SHFLAG

	LDA #<MODE1
	STA KEYTAB
	LDA #>MODE1
	STA KEYTAB+1
        LDA KBCODE
	AND #$3F
	TAY
	LDA (KEYTAB),Y  ;GET CHAR CODE
	STY SFDX        ;SAVE KEY NUMBER
	JMP (KEYLOG)    ;EVALUATE SHIFT FUNCTIONS
        ; it will return here
REKEY	LDY SFDX        ;GET KEY INDEX
	LDA (KEYTAB),Y   ;GET CHAR CODE INCLUDING SHIFT
	TAX             ;SAVE THE CHAR
	CPY LSTX        ;SAME AS PREV CHAR INDEX?
	BEQ RPT10       ;YES
	LDY #$10        ;NO - RESET DELAY BEFORE REPEAT
	STY DELAY
	BNE CKIT2       ;ALWAYS
RPT10	AND #$7F        ;UNSHIFT IT
	BIT RPTFLG      ;CHECK FOR REPEAT DISABLE
	BMI RPT20       ;YES
	BVS SCNRTS
	CMP #$7F        ;NO KEYS ?
SCNOUT	BEQ CKIT2       ;YES - GET OUT
	CMP #$14        ;AN INST/DEL KEY ?
	BEQ RPT20       ;YES - REPEAT IT
	CMP #$20        ;A SPACE KEY ?
	BEQ RPT20       ;YES
	CMP #$1D        ;A CRSR LEFT/RIGHT ?
	BEQ RPT20       ;YES
	CMP #$11        ;A CRSR UP/DWN ?
	BNE SCNRTS      ;NO - EXIT
RPT20	LDY DELAY       ;TIME TO REPEAT ?
	BEQ RPT40       ;YES
	DEC DELAY
	BNE SCNRTS
RPT40	DEC KOUNT       ;TIME FOR NEXT REPEAT ?
	BNE SCNRTS      ;NO
	LDY #4          ;YES - RESET CTR
	STY KOUNT
	LDY NDX         ;NO REPEAT IF QUEUE FULL
	DEY
	BPL SCNRTS
CKIT2
	LDY SFDX        ;GET INDEX OF KEY
	STY LSTX        ;SAVE THIS INDEX TO KEY FOUND
	LDY SHFLAG      ;UPDATE SHIFT STATUS
	STY LSTSHF
CKIT3	CPX #$FF        ;A NULL KEY OR NO KEY ?
	BEQ SCNRTS      ;BRANCH IF SO
	TXA             ;NEED X AS INDEX SO...
	LDX NDX         ;GET # OF CHARS IN KEY QUEUE
	CPX XMAX        ;IRQ BUFFER FULL ?
	BCS SCNRTS      ;YES - NO MORE INSERT
PUTQUE
	STA KEYD,X      ;PUT RAW DATA HERE
	INX
	STX NDX         ;UPDATE KEY QUEUE COUNT
SCNRTS	
	IFCONST DEBUG
	; debugging status
	LDA KBCODE
	LSR
	LSR
	LSR
	LSR
	TAX
	LDA HEXES,X
	STA $0400
	LDA KBCODE
	AND #$0F
	TAX
	LDA HEXES,X
	STA $0401
	
	LDA SHFLAG
	STA $0403
	LDA STKEY
	STA $0405
	LDA IRQST
	AND #$C0
	STA $0407
	ENDIF

	RTS

HEXES   .BYTE "0123456789",1,2,3,4,5,6
;
; SHIFT LOGIC
;
SHFLOG
	LDA SHFLAG
	;CMP #$03        ;COMMODORE SHIFT COMBINATION?
	; actually check for just shift
	CMP #$01
	BNE KEYLG2
	CMP LSTSHF      ;DID I DO THIS ALREADY
	BEQ SCNRTS      ;BRANCH IF SO
	LDA SFDX        ; 
	CMP #$27        ; ATARI/REVERSE KEY?
	BNE KEYLG2
	CMP LSTX	;DID I DO THIS ALREADY
	BEQ SCNRTS	;BRANCH IF SO
	LDA MODE
	BMI SHFOUT      ;DONT SHIFT IF ITS MINUS

SWITCH	LDA CHSHADOW
	EOR #$04
	STA CHSHADOW
	STA CHBASE
	;JMP SHFOUT ; if we just do this, it types a pi
	; but if we clear SFDX we can't debounce anymore
	LDA #$2   ;make sure the SHIFT keymap is used
	BNE NCTRL ;and continue as normal

;
KEYLG2
	LDA SHFLAG
	ASL             ; A=2 if it's SHIFT
	CMP #$08        ;WAS IT A CONTROL KEY
	BCC NCTRL       ;BRANCH IF NOT
	LDA #6          ;ELSE USE TABLE #4
;
NCTRL
	TAX
	LDA KEYCOD,X
	STA KEYTAB
	LDA KEYCOD+1,X
	STA KEYTAB+1
SHFOUT
	JMP REKEY

; RSR 12/08/81 MODIFY FOR VIC-40
; RSR  2/18/82 MODIFY FOR 6526 INPUT PAD SENSE
; RSR  3/11/82 FIX KEYBOARD DEBOUNCE, REPAIR FILE
; RSR  3/11/82 MODIFY FOR COMMODORE 64
